/**
 * Utility to get Monaco worker URLs with hashed filenames
 * Workers are generated by the bundler with content hashes
 * 
 * The bundler creates worker files with hashed names (e.g., json.worker.b816b254.js).
 * We'll use dynamic imports to get the actual worker URLs from the bundled files.
 */

// Cache for worker URLs to avoid repeated lookups
const workerUrlCache: Record<string, string> = {}

/**
 * Get Monaco worker URL for a given language label
 * Uses dynamic imports to resolve the actual hashed worker filenames
 */
export async function getMonacoWorkerUrl(label: string): Promise<string> {
  // Check cache first
  if (workerUrlCache[label]) {
    return workerUrlCache[label]
  }

  const basePath = chrome.runtime.getURL("")
  
  // Map language labels to worker file base names
  const workerMap: Record<string, string> = {
    json: "json.worker",
    css: "css.worker",
    scss: "css.worker",
    less: "css.worker",
    html: "html.worker",
    handlebars: "html.worker",
    razor: "html.worker",
    typescript: "ts.worker",
    javascript: "ts.worker",
  }

  const workerBase = workerMap[label.toLowerCase()] || "editor.worker"
  
  try {
    // Try to dynamically import the worker - this should resolve to the hashed filename
    // Note: This might not work directly, so we'll fall back to base filename
    const workerUrl = `${basePath}${workerBase}.js`
    workerUrlCache[label] = workerUrl
    return workerUrl
  } catch (error) {
    // Fallback to base filename
    const workerUrl = `${basePath}${workerBase}.js`
    workerUrlCache[label] = workerUrl
    return workerUrl
  }
}

/**
 * Initialize Monaco environment with worker configuration
 * This should be called before creating any Monaco editor instances
 */
export function initMonacoEnvironment() {
  if (typeof window === "undefined") return

  ;(window as any).MonacoEnvironment = {
    getWorkerUrl: async function (_moduleId: string, label: string) {
      // For now, use synchronous approach with base filenames
      // The extension's module resolution should handle finding the hashed files
      // If this doesn't work, we may need to use a build-time solution
      const basePath = chrome.runtime.getURL("")
      const workerMap: Record<string, string> = {
        json: "json.worker.js",
        css: "css.worker.js",
        scss: "css.worker.js",
        less: "css.worker.js",
        html: "html.worker.js",
        handlebars: "html.worker.js",
        razor: "html.worker.js",
        typescript: "ts.worker.js",
        javascript: "ts.worker.js",
      }
      const workerFile = workerMap[label.toLowerCase()] || "editor.worker.js"
      return `${basePath}${workerFile}`
    },
  }
}

